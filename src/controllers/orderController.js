// Import c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt
const crypto = require('crypto'); // Th∆∞ vi·ªán m√£ h√≥a d√πng ƒë·ªÉ t·∫°o ch·ªØ k√Ω b·∫£o m·∫≠t
const moment = require('moment'); // Th∆∞ vi·ªán x·ª≠ l√Ω th·ªùi gian
const qs = require('qs'); // Th∆∞ vi·ªán ƒë·ªÉ x·ª≠ l√Ω chu·ªói query
const { Orders_detail, Orders, Product_variants,Products, sequelize ,Sizes,Colors,Discount_codes} = require('../models'); // Import model t·ª´ Sequelize
const { includes } = require('lodash');

// C·∫•u h√¨nh th√¥ng tin VNPAY
const VNPAY = {
    tmnCode: 'Y23UTK8D', // M√£ terminal ƒë∆∞·ª£c VNPAY cung c·∫•p
    hashSecret: 'ZQ7X0L2ETEVQ8WQJRAT3B15TNEO7XMXT', // Secret key ƒë·ªÉ t·∫°o ch·ªØ k√Ω
    url: 'https://sandbox.vnpayment.vn/paymentv2/vpcpay.html', // URL trang thanh to√°n sandbox
    returnUrl: 'http://localhost:3000/orders/vnpay/return', // URL callback sau khi thanh to√°n
};

// B·ªô nh·ªõ t·∫°m ƒë·ªÉ l∆∞u ƒë∆°n h√†ng ch·ªù thanh to√°n (production n√™n d√πng Redis)
const pendingOrders = new Map();

// H√†m ki·ªÉm tra t·ªìn kho
const validateStock = async (items, transaction) => {
    for (const item of items) {
        const variant = await Product_variants.findByPk(item.product_variant_id, { transaction });
        if (!variant) {
            throw new Error(`Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m v·ªõi ID: ${item.product_variant_id}`);
        }
        if (variant.stock_quantity < item.quantity) {
            throw new Error(`S·∫£n ph·∫©m kh√¥ng ƒë·ªß s·ªë l∆∞·ª£ng. C√≤n l·∫°i: ${variant.stock_quantity}`);
        }
    }
};

// H√†m tr·ª´ s·ªë l∆∞·ª£ng t·ªìn kho
const decrementStock = async (items, transaction) => {
    await Promise.all(items.map(item =>
        Product_variants.decrement('stock_quantity', {
            by: item.quantity,
            where: { id: item.product_variant_id },
            transaction
        })
    ));
};

// T·∫°o b·∫£n ghi ƒë∆°n h√†ng v√† chi ti·∫øt ƒë∆°n h√†ng
const createOrderRecord = async (orderId, orderData, items, status, transaction, extraFields = {}) => {
    const order = await Orders.create({
        id: orderId,
        ...orderData,
        status,
        ...extraFields
    }, { transaction });

    await Orders_detail.bulkCreate(
        items.map(item => ({ order_id: orderId, ...item })),
        { transaction }
    );

    return order;
};

// S·∫Øp x·∫øp object v√† encode theo y√™u c·∫ßu VNPAY
const sortObject = (obj) => {
    const sorted = {};
    Object.keys(obj).sort().forEach(key => {
        sorted[encodeURIComponent(key)] = encodeURIComponent(obj[key]).replace(/%20/g, '+');
    });
    return sorted;
};

// T·∫°o ch·ªØ k√Ω HMAC SHA512 t·ª´ d·ªØ li·ªáu ƒë·∫ßu v√†o
const createSignature = (data) => {
    return crypto.createHmac('sha512', VNPAY.hashSecret)
        .update(Buffer.from(data, 'utf-8'))
        .digest('hex');
};

// L·∫•y IP c·ªßa client
const getClientIP = (req) => {
    return req.headers['x-forwarded-for'] || req.connection.remoteAddress || '127.0.0.1';
};

// T·∫°o URL thanh to√°n VNPAY
const createVNPayUrl = (orderId, amount, ipAddr) => {
    let params = {vnp_Version: '2.1.0',
        vnp_Command: 'pay',
        vnp_TmnCode: VNPAY.tmnCode,
        vnp_Locale: 'vn',
        vnp_CurrCode: 'VND',
        vnp_TxnRef: orderId,
        vnp_OrderInfo: `Thanh toan don hang ${orderId}`,
        vnp_OrderType: 'other',
        vnp_Amount: amount * 100,
        vnp_ReturnUrl: VNPAY.returnUrl,
        vnp_IpAddr: ipAddr,
        vnp_CreateDate: moment().format('YYYYMMDDHHmmss'),
    };

    params = sortObject(params);
    const signData = qs.stringify(params, { encode: false });
    params.vnp_SecureHash = createSignature(signData);

    return `${VNPAY.url}?${qs.stringify(params, { encode: false })}`;
};

// X·ª≠ l√Ω thanh to√°n COD (thanh to√°n khi nh·∫≠n h√†ng)
const handleCODPayment = async (orderId, orderData, items, res) => {
    const t = await sequelize.transaction();
    try {
        await validateStock(items, t);
        const order = await createOrderRecord(orderId, orderData, items, 'Ch·ªù x√°c nh·∫≠n', t);
        if (orderData.discount_code_id) {
          await Discount_codes.increment('used_count', {
            by: 1,
            where: { id: orderData.discount_code_id },
            transaction: t
          });
        }
        await decrementStock(items, t);
        await t.commit();
        return res.json({ success: true, message: 'ƒê·∫∑t h√†ng th√†nh c√¥ng', data: order });
    } catch (error) {
        await t.rollback();
        throw error;
    }
};

// X·ª≠ l√Ω thanh to√°n qua VNPAY
const handleVNPayPayment = async (orderId, orderData, items, req, res) => {
    const t = await sequelize.transaction();
    try {
        await validateStock(items, t);
        await t.commit();

        pendingOrders.set(orderId, { ...orderData, items, created_at: Date.now() });
        setTimeout(() => pendingOrders.delete(orderId), 15 * 60 * 1000); // X√≥a sau 15 ph√∫t

        const paymentUrl = createVNPayUrl(orderId, orderData.total_amount, getClientIP(req));
        return res.json({
            success: true,
            message: 'Vui l√≤ng thanh to√°n ƒë·ªÉ ho√†n t·∫•t ƒë∆°n h√†ng',
            payment_url: paymentUrl,
            order_id: orderId
        });
    } catch (error) {
        await t.rollback();
        throw error;
    }
};

// Controller ch√≠nh ƒë·ªÉ t·∫°o ƒë∆°n h√†ng
const createOrder = async (req, res) => {
  console.log('üî• Order body:', req.body);
    try {
        const {
            user_id, name, address, phone, discount_code_id,
            subtotal, discount_amount, total_amount, payment_method, items
        } = req.body;

        const orderId = `ORDER_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        const orderData = {
            user_id, name, address, phone,
            discount_code_id: discount_code_id || null,
            subtotal, discount_amount, total_amount, payment_method
        };

        if (payment_method === 'COD') {
          console.log("‚û°Ô∏è COD payment ƒë∆∞·ª£c ch·ªçn");
            return await handleCODPayment(orderId, orderData, items, res);
        }

        if (payment_method === 'VNPAY') {
          console.log("‚û°Ô∏è VNPAY payment ƒë∆∞·ª£c ch·ªçn");
            return await handleVNPayPayment(orderId, orderData, items, req, res);
        }
        console.warn("‚ö†Ô∏è Kh√¥ng kh·ªõp ph∆∞∆°ng th·ª©c thanh to√°n:", payment_method);
        return res.status(400).json({ success: false, message: 'Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng h·ª£p l·ªá' });
    } catch (error) {
        console.error('üî• L·ªói khi ƒë·∫∑t h√†ng:', error.message);

        // Ki·ªÉm tra l·ªói li√™n quan ƒë·∫øn t·ªìn kho
        if (error.message.includes('kh√¥ng ƒë·ªß s·ªë l∆∞·ª£ng')) {
          return res.status(400).json({ success: false, message: error.message });
        }
      
        return res.status(500).json({ success: false, message: 'L·ªói h·ªá th·ªëng' });
      }
};

// X·ª≠ l√Ω callback t·ª´ VNPAY sau thanh to√°n
const vnpayReturn = async (req, res) => {
  console.log('üì• VNPAY callback nh·∫≠n ƒë∆∞·ª£c:', req.query);
    try {
        const params = { ...req.query };
        const secureHash = params.vnp_SecureHash;
        delete params.vnp_SecureHash;
        delete params.vnp_SecureHashType;

        const sortedParams = sortObject(params);
        const signData = qs.stringify(sortedParams, { encode: false });
        const signature = createSignature(signData);

        const frontendUrl = 'http://localhost:8080/vnpay-return';

        if (secureHash !== signature) {
          return res.redirect(`${frontendUrl}?status=fail&message=Ch·ªØ+k√Ω+kh√¥ng+h·ª£p+l·ªá`);
        }

        const orderId = params.vnp_TxnRef;
        const isSuccess = params.vnp_ResponseCode === '00';

        if (!isSuccess) {
          pendingOrders.delete(orderId);
          return res.redirect(`${frontendUrl}?status=fail&vnp_TxnRef=${orderId}&message=Thanh+to√°n+th·∫•t+b·∫°i`);

        }

        const orderData = pendingOrders.get(orderId);
        if (!orderData) {
          return res.redirect(`${frontendUrl}?status=fail&vnp_TxnRef=${orderId}&message=Kh√¥ng+t√¨m+th·∫•y+th√¥ng+tin+ƒë∆°n+h√†ng`);
        }

        const t = await sequelize.transaction();
        try {
            await validateStock(orderData.items, t);
            const order = await createOrderRecord(
                orderId,
                orderData,
                orderData.items,
                'ƒê√£ x√°c nh·∫≠n',
                t,
                {
                    payment_method: 'VNPAY',
                    payment_date: new Date(),
                    vnpay_transaction_id: params.vnp_TransactionNo
                }
            );
            if (orderData.discount_code_id) {
              await Discount_codes.increment('used_count', {
                by: 1,
                where: { id: orderData.discount_code_id },
                transaction: t
              });
            }

            await decrementStock(orderData.items, t);
            await t.commit();

            pendingOrders.delete(orderId);

            return res.redirect(`${frontendUrl}?status=success&vnp_TxnRef=${orderId}&message=Thanh+to√°n+th√†nh+c√¥ng`);
        } catch (error) {
          await t.rollback();
          return res.redirect(`${frontendUrl}?status=fail&vnp_TxnRef=${orderId}&message=L·ªói+h·ªá+th·ªëng`);
        }

    } catch (error) {
      console.error('üî• To√†n b·ªô l·ªói vnpayReturn:', error);
      return res.redirect(`${frontendUrl}?status=fail&vnp_TxnRef=${orderId}&message=L·ªói+h·ªá+th·ªëng`);
    }
};
//get danh sach order
const danhSachOrder = async (req, res) => {
  try {
    const danhsach = await Orders.findAll({
      include: [
        {
          model: Orders_detail,
          as: 'orderItems',
          include: [
            {
              model: Product_variants,
              as: 'product_variant',
              attributes: ['id', 'product_id', ],
              include: [
            {
              model: Products,
              as: 'product',
              attributes: ['name'],
            },
            {
              model: Sizes,
              as: 'sizes',
              attributes: ['name'], 
            },
            {
              model: Colors,
              as: 'colors',
              attributes: ['name'], 
            },
          ]
            }
          ]
        }
      ],
      order: [['createdAt', 'DESC']]
    });

    return res.status(200).json({
      success: true,
      message: "L·∫•y danh s√°ch order th√†nh c√¥ng",
      data: danhsach
    });
  } catch (error) {
    return res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

const updateOrderStatus = async (req, res) => {
    const { id } = req.params;
    const status = req.body?.status || req.query?.status;
    const allowedStatus = ['Ch·ªù x√°c nh·∫≠n', 'ƒê√£ x√°c nh·∫≠n', 'ƒêang v·∫≠n chuy·ªÉn', 'ƒê√£ giao', 'ƒê√£ h·ªßy', 'Thanh to√°n th·∫•t b·∫°i'];

    if (!allowedStatus.includes(status)) {
        return res.status(400).json({ success: false, message: 'Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá' });
    }

    try {
        const order = await Orders.findByPk(id);
        if (!order) return res.status(404).json({ success: false, message: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });

        order.status = status;
        await order.save();

        res.json({ success: true, message: 'C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng', data: order });
    } catch (error) {res.status(500).json({ success: false, error: error.message });
    }
};
const cancelOrder = async (req, res) => {
  const order_id = req.params.id; // ‚úÖ L·∫•y ID ƒë∆°n h√†ng t·ª´ URL params, v√≠ d·ª•: /orders/:id/cancel
  const t = await sequelize.transaction(); // üîÅ B·∫Øt ƒë·∫ßu m·ªôt transaction ƒë·ªÉ ƒë·∫£m b·∫£o thao t√°c CSDL di·ªÖn ra an to√†n

  try {
    // üîç T√¨m ƒë∆°n h√†ng theo ID, ƒë·ªìng th·ªùi l·∫•y danh s√°ch s·∫£n ph·∫©m chi ti·∫øt trong ƒë∆°n
    const order = await Orders.findByPk(order_id, {
      include: [{ model: Orders_detail, as: 'orderItems' }],
      transaction: t
    });

    // ‚ùå N·∫øu kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng
    if (!order) {
      await t.rollback();
      return res.status(404).json({
        success: false,
        message: 'ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i'
      });
    }

    // ‚ö†Ô∏è Ch·ªâ cho hu·ª∑ ƒë∆°n khi ƒë∆°n c√≤n ·ªü tr·∫°ng th√°i "Ch·ªù x√°c nh·∫≠n"
    if (order.status !== 'Ch·ªù x√°c nh·∫≠n') {
      await t.rollback();
      return res.status(400).json({
        success: false,
        message: `ƒê∆°n h√†ng kh√¥ng th·ªÉ hu·ª∑ ·ªü tr·∫°ng th√°i hi·ªán t·∫°i: ${order.status}`
      });
    }

    // ‚ôªÔ∏è Duy·ªát t·ª´ng s·∫£n ph·∫©m trong ƒë∆°n ƒë·ªÉ ho√†n tr·∫£ s·ªë l∆∞·ª£ng v·ªÅ kho
    for (const item of order.orderItems) {
      console.log("Hu·ª∑ ƒë∆°n ‚Üí ho√†n kho:", {
        variantId: item.product_variant_id,
        quantity: item.quantity
      });

      // üîÑ TƒÉng t·ªìn kho c·ªßa bi·∫øn th·ªÉ s·∫£n ph·∫©m t∆∞∆°ng ·ª©ng
      await Product_variants.increment(
        { stock_quantity: item.quantity },
        { where: { id: item.product_variant_id }, transaction: t }
      );
    }

    // ‚úÖ C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh "ƒê√£ hu·ª∑"
    order.status = 'ƒê√£ h·ªßy';
    await order.save({ transaction: t });

    // üíæ Commit transaction n·∫øu kh√¥ng c√≥ l·ªói
    await t.commit();
    return res.json({ success: true, message: 'ƒê√£ hu·ª∑ ƒë∆°n h√†ng th√†nh c√¥ng' });

  } catch (error) {
    // ‚ùó C√≥ l·ªói x·∫£y ra ‚Üí rollback
    await t.rollback();
    console.error("L·ªói hu·ª∑ ƒë∆°n:", error);
    return res.status(500).json({ success: false, message: 'L·ªói khi hu·ª∑ ƒë∆°n h√†ng' });
  }
};
// Export c√°c controller
module.exports =
{
    createOrder,
    vnpayReturn,
    danhSachOrder,
    updateOrderStatus,
    cancelOrder
};